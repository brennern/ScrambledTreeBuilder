---
title: "ScrambledTreeBuilder"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ScrambledTreeBuilder}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r knitr_setup}
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

The _ScrambledTreeBuilder_ package consists of numerous data formatting
functions for phylogenetic tree building in the context of the (still internal)
[Scrambling in the Tree of Life](https://github.com/oist/LuscombeU_ScramblingInTheTreeOfLife)
project.

# Load Package

The _ScrambledTreeBuilder_ package outputs plots in _ggplot2_ format but you
need to load the _ggplot2_ package to further customize them.

```{r R_setup}
library(ScrambledTreeBuilder) |> suppressPackageStartupMessages()
library(ggplot2)              |> suppressPackageStartupMessages()
```

# Example Data

This package utilizes example YAML files containing summary statistics of
halobacteria genome comparison data. In regards to genome scrambling, many
studies have showcased significant genome rearrangements in such halobacteria
species due to dozens of insertion sequence families.

The YAML summary files are produced by performing an all vs. all genome
comparison between six halobacteria species using the 
[nf-core pairwise genome alignment pipeline](https://nf-co.re/pairgenomealign/)
and an [post-processing pipeline](https://github.com/oist/plessy_nf_GenomicBreaks)
running functions from the [GenomicBreaks](https://github.com/oist/GenomicBreaks)
package to extract statistics on alignment length and the extent of genome scrambling.
Examples YAML files are stored in `extdata/yaml`.  Each file represent one
pairwise alignment, and the file names conveys the identifiers of the _target_
and _query_ genomes (here species names) separed with three underscores (`___`).

Here we prepare an object called 'yamlFileData' that contains the path to the files.

```{r list_data_files}
yamlFileData <- system.file("extdata/yaml", package = "ScrambledTreeBuilder") |>
  resultFiles()
yamlFileData[1]
```

Next, we use the `formatStats()` function to load the YAML files into a
single dataframe where each line is a pair of species and each column is
a statistic or a metadata about that species comparison.

```{r results_DF}
exDataFrame <- formatStats(yamlFileData)
ncol(exDataFrame)
colnames(exDataFrame) |> head()
colnames(exDataFrame) |> grep(pat = "_Mean", value = TRUE) |> head()
colnames(exDataFrame) |> tail()
```

This data frame has a large number of columns, providing summary statistics
on various aspects of the alignments.  For statistics of interest, we build
square matrices where rows and columns indicate one species, and the cells at
each intersection contain the value for that pair.

We perform this task with the `makeMatrix()` function.  It provide defaults for
missing values and self-comparisons.  In this vignette, let's focus on the
percent nucleotide difference and the scrambling index.

```{r distance_matrix }
# Percent nucleotide difference  We will use it to cluster a tree.
treeMatrix <- 100 - makeMatrix(exDataFrame, "percent_identity_global", 100, 50)
round(treeMatrix)
```

```{r scrambling_index_matrix}
# Scrambling index
valueMatrix <- 1 - makeMatrix(exDataFrame, "index_avg_strandRand", 1, 0.5)
round(valueMatrix, 2)
```

# Tree clustering

We cluster the percent nucleotide difference matrix (`treeMatrix`) to produce
a tree in _tibble_ format, using the `makeTidyTree()` function.

```{r tree}
# Let's average the target-query and query-target replicate pairs.
(Tibble <- makeTidyTree((treeMatrix/2 + t(treeMatrix)/2)))
```

```{r Tree_with_node_IDs}
visualizeTree(Tibble)
```

The node IDs can be used to manipulate the tree, for instance subsetting with
the `subtree()` function.

```{r subTree_with_node_IDs}
visualizeTree(Tibble |> subTree(9))
```

# Focal clades

Clades of interest, which we call _focal clades_ (焦点系統群) can be tracked and highlighted by `FocalClade` objects.
For robustness against changes in the input data or clustering approach, it
is recommented to define a clade by the most recent common ancestor from a
pair of species.  The `subTree()` function can take `FocalClade` objects
instead of node IDs as input.

```{r focalClade}
(Halobacterium <- focalClade(Tibble, "Halobacterium_noricense", "Halobacterium_salinarum", "blue", "Halobacterium genus"))
Halobacterium@genomeIDs
Halobacterium@nodeID
subTree(Tibble, Halobacterium)
```

The focal clade objects can be added to plots to highlight the clades in the
selected colors.

```{r focalCladeList}
Haloferax <- focalClade(Tibble, "Haloferax_mediterranei", "Haloferax_volcanii", "green3", "Haloferax genus")
(clades <- FocalCladeList(Halobacterium=Halobacterium, Haloferax=Haloferax))
visualizeTree(Tibble) + clades + ggtitle("Focal clade highlight")
```

# Heatmaps

To further quality control the tree and its genomes, it is possible to plot
the values from the distance matrices as a heatmap in which rows and columns
are in the same order as the branches of the tree.  Focal clades can be
highlighted too.

```{r heatmaps}
treeHeatMap(treeMatrix,  Tibble, clades, main = "Percent difference")
treeHeatMap(valueMatrix, Tibble, clades, main = "Scrambling index")
```

# Projecton on most recent common ancestors

To plot more data on the tree, we add other statistics to the tree object, here
the scrambling index and the percent nucleotide difference, using the
`makeValueTibble()` function.  This operation reduces a pairwise matrix to the
tree, by averaging all the pairs sharing the same most recent common ancestor,
represented by an internal node in the tree.

```{r add_SI_to_tree}
(tibbleWithValues <- makeValueTibble(Tibble, valueMatrix, colname = "Scrambling_index"))
```

```{r add_distance_to_tree}
(tibbleWithMultipleValues <- makeValueTibble(tibbleWithValues, treeMatrix, colname = "Percent_difference"))
```

We made multiple tables to show the step-by-step process, but typically one
would just keep the last table.  This can be done with pipes.

```{r create_tree_with_pipes}
makeTidyTree((treeMatrix/2 + t(treeMatrix)/2)) |>
  makeValueTibble(valueMatrix, colname = "Scrambling_index") |>
  makeValueTibble(treeMatrix,  colname = "Percent_difference")
# Same result
```

## Plot trees with values

Let's use the `tibbleWithMultipleValues` object to plot trees.  In our case, we
have generated a tree built based on nucleotide percent difference values as a
distance, and computed average scrambling index for all the nodes.
We can plot these values as labels on the tree.

```{r tree_with_SI}
visualizeTree(tibbleWithMultipleValues, "Scrambling_index") +
  ggplot2::ggtitle(paste("Tree built with Percent difference and labelled with Scrambling Index")) + clades
```

```{r two_value_plot}
visualizeTree(tibbleWithMultipleValues, tibbleWithMultipleValues$Scrambling_index, ynudge = 0.2) +
  ggplot2::ggtitle("Tree labeled with Scrambling Index and Percent Difference") +
  ggplot2::scale_color_viridis_c(name = "Scrambling index", option = "cividis") +
  ggnewscale::new_scale_colour() +
  ggtree::geom_label(ggtree::aes(label=round(Percent_difference), color = Percent_difference), label.size = 0.25, size = 3, na.rm = TRUE, label.padding = ggtree::unit(0.15, "lines"), nudge_y = -0.2) +
  viridis::scale_color_viridis(option = "magma", name = "Percent Identity")
```

Of course, if you spotted an interesting sub-tree, you can plot the node IDs
to easily extract it for further analysis.

```{r tree_with_node_IDs_again}
visualizeTree(tibbleWithMultipleValues)
```

The `subTree` function can conveniently be used with R's pipe operator to cut
a sub-tree at a chosen node.

```{r subTree_node_9}
visualizeTree(tibbleWithMultipleValues |> subTree(node = 9), "Percent_difference")
```

```{r sub_matrix_node_9}
subMatrix(Tibble, valueMatrix, 9, simpl=TRUE)
```

# Pairwise MRCA plots

We can annotate all the pairs of values according to what is their most recent
common ancestor (MRCA) in our phylogenetic tree.  Once we have done that, we can
plot statistics against each other.  Most often we will chose the horizontal
axis to be correlated with time, for instance with percent difference.

In the MRCA 2D kind of plots, values are aggregated by common ancestor, and
ploted with error bars (which we do not see here because there is not enough
data).  MRCAs are colored by their focal clade.

```{r MRCA_plot}
exDataFrame <- recordAncestor(exDataFrame, Tibble)
MRCAs( exDataFrame, clades
     , dim1 = "percent_difference_local"
     , dim2 = "index_avg_strandDiscord") |>
  MRCA_2D_plot()
```

In ellipse plots, all the pairs of species are displayed and grouped by MRCA.
These groups are colored by focal clades.  Remember that we have two values
per pair of species (A vs B and B vs A).  To simplify the plot, use the
`averageResults()` function like below.

```{r ellipse_plot}
exDataFrame <- recordClades(exDataFrame, clades)
ellipsePlot( exDataFrame
           , dim1 = "percent_difference_local"
           , dim2 = "index_avg_strandDiscord")
ellipsePlot( exDataFrame |> averageResults()
           , dim1 = "percent_difference_local"
           , dim2 = "index_avg_strandDiscord")
```
